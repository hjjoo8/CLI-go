// main.go
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"math"
	"os"
	"strconv"
	"strings"
)

// str리스트 타입 생성
type stringList []string

// str리스트의 string()메서드
func (s *stringList) String() string {
	return fmt.Sprintf("%v", *s)
}

// str리스트의 set()메서드
func (s *stringList) Set(value string) error {
	*s = strings.Split(value, ",")
	//*s = append(*s, value)
	return nil
}

// str리스트 변수 생성
var myFlags stringList

// json 데이터 구조 객체
type AutoGenerated struct {
	Type     string `json:"type"`
	Features []struct {
		Type     string `json:"type"`
		Geometry struct {
			Type        string      `json:"type"`
			Coordinates [][]float64 `json:"coordinates"`
		} `json:"geometry"`
		Properties struct {
			ID string `json:"id"`
		} `json:"properties"`
	} `json:"features"`
}

//하버사인공식으로 두 위도 경도 좌표 사이의 거리를 구하는 함수
func calDistancebyHaversine(x1, y1, x2, y2 float64) float64 {
	var HaverDistance float64
	var radius float64 = 6371000 //지구반지름(m)
	toRadian := math.Pi / 180.0

	deltaLat := math.Abs(x1-x2) * toRadian //위도
	deltaLng := math.Abs(y1-y2) * toRadian //경도

	sinDeltaLat := math.Sin(deltaLat / 2)
	sinDeltaLng := math.Sin(deltaLng / 2)
	squareRoot := math.Sqrt(sinDeltaLat*sinDeltaLat + math.Cos(x1*toRadian)*math.Cos(x2*toRadian)*sinDeltaLng*sinDeltaLng)

	HaverDistance = 2 * radius * math.Asin(squareRoot) * 1000 //m로 변환

	return HaverDistance
}

func main() {

	var Px float64                       // 입력된 위도
	var Py float64                       // 입력된 경도
	var min_distance float64 = 1000000.0 // 최단거리
	var min_Hx float64                   // 가까운 좌표의 위도
	var min_Hy float64                   // 가까운 좌표의 경도
	var arr [2]float64

	//flag를 사용해서 cmd에서 입력된 json 파일과 위도와 경도 정보 저장
	jsonAddrs := flag.String("links", "", "linkjson")
	flag.Var(&myFlags, "target", "description")

	flag.Parse()

	//입력된 위도와 경도의 데이터형을 변환하여(str->float), 변수에 저장
	for i, str := range myFlags {
		tmp, _ := strconv.ParseFloat(str, 64)
		arr[i] = tmp
	}

	Px = arr[0]
	Py = arr[1]

	if flag.NFlag() == 0 {
		flag.Usage()
		return
	}

	// json 데이터 구조 변수 생성
	var autogenerate AutoGenerated

	data, err := os.Open(*jsonAddrs)

	//데이터 파일 오픈 및 로딩
	if err != nil {
		fmt.Println(err)
	}
	byteValue, _ := ioutil.ReadAll(data)

	//json 디코딩
	json.Unmarshal(byteValue, &autogenerate)

	// 가장 가까운 링크 위 좌표 찾기
	for index, _ := range autogenerate.Features {
		Xa := autogenerate.Features[index].Geometry.Coordinates[0][0]
		Ya := autogenerate.Features[index].Geometry.Coordinates[0][1]
		Xb := autogenerate.Features[index].Geometry.Coordinates[1][0]
		Yb := autogenerate.Features[index].Geometry.Coordinates[1][1]

		var a1 float64 = (Ya - Yb) / (Xa - Xb)
		var b1 float64 = 1.0
		var c float64 = -(a1*Xa + b1*Ya)

		// a1*x + b1*y + c = 0 방정식과 (Px, Py) 사이의 거리 구하기
		powavb := (math.Pow(a1, 2.0) / b1)
		var denominator float64
		denominator = math.Abs(a1*Px + b1*Py + c)
		numerator2 := math.Pow(a1, 2.0) + math.Pow(b1, 2.0)
		numerator := math.Sqrt(numerator2)
		distance := denominator / numerator

		//H (Hx, Hy)구하기
		Hy := (1 / (powavb + b1)) * (-Px*a1 - c + (Py * powavb))
		Hx := a1*(Hy-Py)/b1 + Px

		if min_distance > distance { //최단 거리 정보 저장
			min_distance = distance
			min_Hx = Hx
			min_Hy = Hy
		}
	}
	//최단거리를 가진 (Hx, Hy)와 (Px, Py) 사이의 거리 구하기(하버사인 공식) (단위:m)
	min_distance = calDistancebyHaversine(Px, Py, min_Hx, min_Hy)
	fmt.Println(min_distance, min_Hx, min_Hy)
}
